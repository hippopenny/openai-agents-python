from __future__ import annotations

import asyncio
import base64
import io
import json
import logging
import os
import platform
import re
import uuid
from io import BytesIO
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Type, TypeVar, cast

from dotenv import load_dotenv
from pydantic import BaseModel # Keep pydantic for internal models if needed
from PIL import Image, ImageDraw, ImageFont

# Re-introduce agents SDK imports
from agents import Agent, Runner, trace, TResponseInputItem, ItemHelpers, RunResult

# Imports from this refactored package
from .agent import orchestrator_agent # Import the main agent
from .context import BaseContext, BrowserContextImpl # Import context classes
from .controller import ActionController # Import controller
from .message_manager import MessageManager # Import message manager
from .planner import planner_agent # Import the planner AGENT now
from .prompts import AgentMessagePrompt # Import prompt formatter
from .views import AgentHistory, AgentHistoryList, PlannerOutput # Keep history views

load_dotenv()
logger = logging.getLogger(__name__)

T = TypeVar('T', bound=BaseModel)


# ----------------------------------------------------------
# 5. Orchestration Logic (Based on high-level example)
# ----------------------------------------------------------

@trace("Browser Agent Orchestration") # Add tracing to the main function
async def main_orchestration(task: str = "Example Task: Find contact info on example.com") -> None:
    """
    Runs the orchestration flow based on the high-level example structure,
    using the agents SDK's Agent and Runner.
    """
    logger.info(f"Starting orchestration for task: {task}")

    # --- Initialization ---
    # Create context instance (using placeholder implementation)
    browser_context = BrowserContextImpl()
    # Create message manager instance
    msg_manager = MessageManager()
    # Create Action controller using the browser context
    action_controller = ActionController(browser_context)
    # History tracking (optional, based on previous structure)
    full_history = AgentHistoryList(history=[])
    # Conversation state for the Runner - starts with the user task
    conversation_inputs: list[TResponseInputItem] = [{"role": "user", "content": task}]

    max_steps = 5 # Limit steps for this example
    previous_action_results: List[Dict] = []
    current_plan: PlannerOutput | str | None = None # To store the latest plan

    try:
        for current_step in range(1, max_steps + 1):
            logger.info(f"--- Orchestration Step {current_step}/{max_steps} ---")

            # 1. Get state from context
            current_state = await browser_context.get_state()
            # Add state to message manager *before* planning
            state_message = f"State @ Step {current_step}: {json.dumps(current_state)}"
            msg_manager.add_message(state_message)

            # 2. Generate a plan using the planner_agent
            # Prepare input for the planner agent (e.g., the history so far)
            # Convert string history to TResponseInputItem list
            planner_input_list: List[TResponseInputItem] = [
                {"role": "user", "content": msg} for msg in msg_manager.get_history()
            ]
            # Add the initial task if it's not implicitly in the history yet
            if not any(item["content"] == task for item in planner_input_list):
                 planner_input_list.insert(0, {"role": "user", "content": task})

            logger.info(f"Running planner_agent (Step {current_step})...")
            try:
                planner_result: RunResult = await Runner.run(
                    planner_agent,
                    input=planner_input_list,
                    # context=... # Pass context if planner agent needed it (unlikely)
                    max_turns=1 # Planner should respond in one turn
                )
                # Extract the structured plan output
                current_plan = planner_result.final_output_as(PlannerOutput, raise_if_incorrect_type=True)
                plan_str = current_plan.model_dump_json(indent=2)
                logger.info(f"Plan generated by planner_agent:\n{plan_str}")
                # Add plan to message manager for the orchestrator
                msg_manager.add_message(f"Plan @ Step {current_step}:\n{plan_str}")

            except Exception as e:
                logger.error(f"Planner agent failed: {e}", exc_info=True)
                current_plan = f"Error generating plan: {e}"
                msg_manager.add_message(f"Plan @ Step {current_step}: {current_plan}")


            # 3. Format input for the orchestrator agent
            # The orchestrator needs the task, plan, state, and potentially previous results
            prompt_formatter = AgentMessagePrompt(
                state=current_state,
                previous_results=previous_action_results,
                plan=current_plan.model_dump() if isinstance(current_plan, PlannerOutput) else current_plan,
                step_info={"step": current_step, "max_steps": max_steps}
            )
            orchestrator_input_content = prompt_formatter.format()

            # Add formatted content as the latest user message for the orchestrator
            # Overwrite previous user message if it exists, otherwise append
            # Use the *current* conversation_inputs which tracks the orchestrator's history
            if conversation_inputs and conversation_inputs[-1]["role"] == "user":
                 conversation_inputs[-1]["content"] = orchestrator_input_content
            else:
                 # Append if history is empty or last message wasn't user
                 conversation_inputs.append({"role": "user", "content": orchestrator_input_content})

            logger.debug(f"Input to orchestrator agent:\n{orchestrator_input_content}")

            # 4. Run the orchestrator agent using agents.Runner
            # The orchestrator should decide which tool (browser_tool or api_tool) to call
            logger.info(f"Running orchestrator_agent (Step {current_step})...")
            orchestrator_result = await Runner.run(
                orchestrator_agent,
                input=conversation_inputs,
                # context=... # Pass context if tools need it directly (less common with as_tool)
                max_turns=3 # Allow agent -> tool -> agent response cycle
            )

            logger.info("Orchestrator agent finished.")
            # Update conversation history for the next loop iteration
            conversation_inputs = orchestrator_result.to_input_list()

            # Extract results/output from the orchestrator run
            final_text_output = ItemHelpers.text_message_outputs(orchestrator_result.new_items)
            logger.info(f"Orchestrator final text output for step: {final_text_output}")

            # Extract tool results from this step to feed into the next step's prompt
            tool_results_this_step = []
            for item in orchestrator_result.new_items:
                 # Check if item is a tool output (structure might vary slightly based on SDK version/details)
                 # This assumes tool outputs are added as specific items in the history.
                 # Adjust the check based on the actual structure observed in orchestrator_result.new_items
                 if isinstance(item, dict) and item.get("type") == "tool_output": # Example check
                     tool_output_data = item.get("tool_output", {}) # Example extraction
                     tool_results_this_step.append(tool_output_data)
                     logger.info(f"Tool execution result captured: {tool_output_data}")
                 elif hasattr(item, 'type') and item.type == 'tool_output': # Alternative check for dataclass/object
                     tool_output_data = getattr(item, 'tool_output', {})
                     tool_results_this_step.append(tool_output_data)
                     logger.info(f"Tool execution result captured: {tool_output_data}")


            previous_action_results = tool_results_this_step # Feed results back for next step

            # Optional: Detailed History Tracking (using AgentHistoryList)
            # This requires mapping the Runner's output back to the AgentHistory structure
            # step_history = AgentHistory(...)
            # full_history.history.append(step_history)

            # Check for completion
            # Example: if final_text_output.lower().startswith("task complete"):
            #    logger.info("Orchestrator indicated task completion.")
            #    break

    except Exception as e:
        logger.error(f"Orchestration failed: {e}", exc_info=True)
        # Ensure current_step is defined even if loop fails early
        current_step = current_step if 'current_step' in locals() else 0
    finally:
        logger.info("Orchestration loop finished.")
        # --- Cleanup ---
        if hasattr(browser_context, 'close'):
            await browser_context.close()

        # --- Final Output ---
        final_output_message = f"Orchestration complete after {current_step} steps. Final state/results gathered."
        logger.info(final_output_message)
        print("\n--- Orchestration Summary ---")
        print(f"Task: {task}")
        print(f"Final Message: {final_output_message}")
        # print(f"Full History:\n{full_history.model_dump_json(indent=2)}") # If history tracking implemented


# ----------------------------------------------------------
# 6. Entry Point (Kept from high-level example)
# ----------------------------------------------------------

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    # Example of running the orchestration
    asyncio.run(main_orchestration(task="Use browser_tool to navigate to example.com and extract the title."))
