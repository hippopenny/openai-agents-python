from __future__ import annotations

import asyncio
import base64
import io
import json
import logging
import os
import platform
import re
import uuid
from io import BytesIO
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Type, TypeVar, cast

from dotenv import load_dotenv
from pydantic import BaseModel # Keep pydantic for internal models if needed
from PIL import Image, ImageDraw, ImageFont

# Re-introduce agents SDK imports
from agents import Agent, Runner, trace, TResponseInputItem, ItemHelpers, RunResult

# Imports from this refactored package
from .agent import orchestrator_agent # Import the main agent
from .context import BaseContext, BrowserContextImpl # Import context classes
from .controller import ActionController # Import controller
# Removed MessageManager import
from .planner import planner_agent # Import the planner AGENT now
from .prompts import AgentMessagePrompt # Import prompt formatter
from .models import AgentHistory, AgentHistoryList, PlannerOutput # Keep history views

load_dotenv()
logger = logging.getLogger(__name__)

# ----------------------------------------------------------
# 5. Orchestration Logic (Based on high-level example)
# ----------------------------------------------------------

# Removed @trace decorator here
async def main_orchestration(
    context: BaseContext, # Accept BaseContext instead of creating Impl
    action_controller: Optional[ActionController], # Keep optional ActionController if needed elsewhere, though not used in loop
    task: str = "Example Task: Find contact info on example.com",
    max_steps: int = 5 # Added max_steps parameter with default
) -> None:
    """
    Runs the orchestration flow based on the high-level example structure,
    using the agents SDK's Agent and Runner.

    Args:
        context: An instance of BaseContext (or its subclass) to interact with the environment.
        action_controller: An instance of ActionController (Optional, currently unused in loop).
        task: The initial goal for the agent.
        max_steps: The maximum number of steps to execute.
    """
    # Wrap the function body with the trace context manager
    with trace("Browser Agent Orchestration"):
        logger.info(f"Starting orchestration for task: {task} with max_steps={max_steps}")

        # --- Initialization ---
        # Use the provided context instance
        browser_context = context
        # Removed MessageManager instantiation

        # History tracking (optional, based on previous structure)
        full_history = AgentHistoryList(history=[])
        # Conversation state for the Runner - starts with the user task
        conversation_inputs: list[TResponseInputItem] = [{"role": "user", "content": task}]

        # Use the max_steps parameter passed to the function
        previous_action_results: List[Dict] = []
        current_plan: PlannerOutput | str | None = None # To store the latest plan

        # Removed try/finally block for context closing, as context lifecycle is managed outside

        for current_step in range(1, max_steps + 1):
            logger.info(f"--- Orchestration Step {current_step}/{max_steps} ---")

            # 1. Get state from context
            current_state = await browser_context.get_state()
            # Add state to context history *before* planning
            state_message = f"State @ Step {current_step}: {json.dumps(current_state)}"
            browser_context.add_message(state_message) # Use context history

            # 2. Generate a plan using the planner_agent
            # Prepare input for the planner agent (e.g., the history so far from context)
            # Convert string history to TResponseInputItem list
            planner_input_list: List[TResponseInputItem] = [
                {"role": "user", "content": msg} for msg in browser_context.get_history() # Use context history
            ]
            # Add the initial task if it's not implicitly in the history yet
            if not any(item["content"] == task for item in planner_input_list):
                 planner_input_list.insert(0, {"role": "user", "content": task})

            logger.info(f"Running planner_agent (Step {current_step})...")
            try:
                planner_result: RunResult = await Runner.run(
                    planner_agent,
                    input=planner_input_list,
                    context=browser_context, # Pass context to Runner if tools need it
                    max_turns=1 # Planner should respond in one turn
                )
                # Extract the structured plan output
                current_plan = planner_result.final_output_as(PlannerOutput, raise_if_incorrect_type=True)
                plan_str = current_plan.model_dump_json(indent=2)
                logger.info(f"Plan generated by planner_agent:\n{plan_str}")
                # Add plan to context history for the orchestrator
                browser_context.add_message(f"Plan @ Step {current_step}:\n{plan_str}") # Use context history

            except Exception as e:
                logger.error(f"Planner agent failed: {e}", exc_info=True)
                current_plan = f"Error generating plan: {e}"
                browser_context.add_message(f"Plan @ Step {current_step}: {current_plan}") # Use context history
                # Break the loop if planner fails
                break


            # 3. Format input for the orchestrator agent
            # The orchestrator needs the task, plan, state, and potentially previous results
            prompt_formatter = AgentMessagePrompt(
                state=current_state,
                previous_results=previous_action_results,
                plan=current_plan.model_dump() if isinstance(current_plan, PlannerOutput) else current_plan,
                step_info={"step": current_step, "max_steps": max_steps}
            )
            orchestrator_input_content = prompt_formatter.format()

            # Add formatted content as the latest user message for the orchestrator
            # Overwrite previous user message if it exists, otherwise append
            # Use the *current* conversation_inputs which tracks the orchestrator's history
            if conversation_inputs and conversation_inputs[-1]["role"] == "user":
                 conversation_inputs[-1]["content"] = orchestrator_input_content
            else:
                 # Append if history is empty or last message wasn't user
                 conversation_inputs.append({"role": "user", "content": orchestrator_input_content})

            logger.debug(f"Input to orchestrator agent:\n{orchestrator_input_content}")

            # 4. Run the orchestrator agent using agents.Runner
            # The orchestrator should decide which tool (browser_tool or api_tool) to call
            logger.info(f"Running orchestrator_agent (Step {current_step})...")
            try:
                orchestrator_result = await Runner.run(
                    orchestrator_agent,
                    input=conversation_inputs,
                    context=browser_context, # Pass context to Runner if tools need it
                    max_turns=3 # Allow agent -> tool -> agent response cycle
                )
            except Exception as e:
                logger.error(f"Orchestrator agent failed in step {current_step}: {e}", exc_info=True)
                # Decide how to handle orchestrator failure (e.g., break, retry, log)
                # For now, just log and break the loop
                break # Exit loop on orchestrator error

            logger.info("Orchestrator agent finished.")
            # Update conversation history for the next loop iteration
            conversation_inputs = orchestrator_result.to_input_list()

            # Extract results/output from the orchestrator run
            final_text_output = ItemHelpers.text_message_outputs(orchestrator_result.new_items)
            logger.info(f"Orchestrator final text output for step: {final_text_output}")
            # Add orchestrator output to context history? Optional, depends on whether planner needs it.
            # browser_context.add_message(f"Orchestrator Output @ Step {current_step}: {final_text_output}")

            # Extract tool results from this step to feed into the next step's prompt
            tool_results_this_step = []
            for item in orchestrator_result.new_items:
                 # Check if item is a tool output (structure might vary slightly based on SDK version/details)
                 # This assumes tool outputs are added as specific items in the history.
                 # Adjust the check based on the actual structure observed in orchestrator_result.new_items
                 if isinstance(item, dict) and item.get("type") == "tool_output": # Example check
                     tool_output_data = item.get("tool_output", {}) # Example extraction
                     tool_results_this_step.append(tool_output_data)
                     logger.info(f"Tool execution result captured: {tool_output_data}")
                 elif hasattr(item, 'type') and item.type == 'tool_output': # Alternative check for dataclass/object
                     tool_output_data = getattr(item, 'tool_output', {})
                     tool_results_this_step.append(tool_output_data)
                     logger.info(f"Tool execution result captured: {tool_output_data}")


            previous_action_results = tool_results_this_step # Feed results back for next step

            # Optional: Detailed History Tracking (using AgentHistoryList)
            # This requires mapping the Runner's output back to the AgentHistory structure
            # step_history = AgentHistory(...)
            # full_history.history.append(step_history)

            # Check for completion
            # Example: if final_text_output.lower().startswith("task complete"):
            #    logger.info("Orchestrator indicated task completion.")
            #    break

        # Ensure current_step is defined even if loop fails early or exits
        current_step = current_step if 'current_step' in locals() else 0

        logger.info("Orchestration loop finished.")
        # --- Final Output ---
        final_output_message = f"Orchestration complete after {current_step} steps. Final state/results gathered."
        logger.info(final_output_message)
        print("\n--- Orchestration Summary ---")
        print(f"Task: {task}")
        print(f"Final Message: {final_output_message}")
        # print(f"Full History:\n{full_history.model_dump_json(indent=2)}") # If history tracking implemented


# ----------------------------------------------------------
# 6. Entry Point (Kept from high-level example)
# ----------------------------------------------------------

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Create the specific context implementation here
    context_instance = BrowserContextImpl()
    # Create Action controller using the browser context
    action_controller = ActionController(context_instance)
    task_to_run = "Use browser_tool to navigate to example.com and extract the title."
    max_steps_for_run = 5 # Define max_steps for the run

    try:
        # Pass the context instance, action controller, and max_steps to the orchestration function
        asyncio.run(main_orchestration(
            context=context_instance,
            action_controller=action_controller,
            task=task_to_run,
            max_steps=max_steps_for_run # Pass max_steps here
        ))
    except Exception as e:
        logger.error(f"An error occurred during orchestration: {e}", exc_info=True)
    finally:
        # Ensure context cleanup happens here, after orchestration finishes or errors
        if hasattr(context_instance, 'close'):
            logger.info("Closing context resources...")
            asyncio.run(context_instance.close()) # Run async close if needed
            logger.info("Context resources closed.")

